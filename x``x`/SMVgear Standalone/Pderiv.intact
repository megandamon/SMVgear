!-----------------------------------------------------------------------------
!
! ROUTINE
!   Pderiv
!
! DESCRIPTION
!   This routine puts the partial derivatives of each ordinary differential
!   equation into a matrix.  The form of the matrix equation is =>
!
!     P = I - H x Bo x J
!
!   where I = identity matrix, H = time step, Bo = coefficient corresponding
!   to the order of the method, and J is the Jacobian matrix of partial
!   derivatives.
!
!   Example of how partial derivatives are placed in an array =>
!
!     Species:          A,   B,   C
!     Concentrations:  (A), (B), (C)
!
!     Reactions:    1) A          --> B      J
!                   2) A  + B     --> C      K1
!                   3) A  + B + C --> D      K2
!
!     First         d(A) / dt = -J(A) - K1(A)(B) - K2(A)(B)(C)
!     Derivatives:  d(B) / dt = +J(A) - K1(A)(B) - K2(A)(B)(C)
!                   d(C) / dt =       + K1(A)(B) - K2(A)(B)(C)
!                   d(D) / dt =                  + K2(A)(B)(C)
!
!     Predictor matrix (P) = I - h * b * J:
!       J = Jacobian matrix of partial derivates
!       I = identity matrix
!       h = time step
!       b = coefficient of method
!       R = h * b = -r1delt
!
!         A                      B                     C                  D
!      _____________________________________________________________________
!     |
!   A | 1-R(-J-K1(B)-K2(B)(C))  -R(-K1(A)-K2(A)(C))   -R(-K2(A)(B))       0
!     |
!   B |  -R(+J-K1(B)-K2(B)(C)) 1-R(-K1(A)-K2(A)(C))   -R(-K2(A)(B))       0
!     |
!   C |  -R(  +K1(B)-K2(B)(C))  -R(+K1(A)-K2(A)(C))  1-R(-K2(A)(B))       0
!     |
!   D |  -R(        +K2(B)(C))  -R(      +K2(A)(C))   -R(+K2(A)(B))       1
!
!
! ARGUMENTS
!   ischan   : # of first-order eqns to solve, = # of spc = order of original
!              matrix; ischan has a different value for day and night, and for
!              gas- and aqueous-phase chemistry;
!              # spc with prod or loss terms in Smvgear (?)
!   ktloop   : # of grid-cells in a grid-block
!   ncsp     : ncs       => for daytime   gas chemistry
!              ncs + ICS => for nighttime gas chemistry
!   nfdh2    : nfdh3 + # of rxns with two   active reactants
!   nfdh3    :         # of rxns with three active reactants
!   nfdl1    : nfdh2 + 1
!   nfdl2    : nfdh3 + 1
!   irma,b,c : spc # of each reactant; locates reordered active spc #s
!   r1delt   : = -aset(nqq,1) * time_step = -coefficient_of_method * dt
!   cnew     : init (and final) spc conc (# cm-3-air or moles l-1-h2o (?))
!   rrate    : rxn rate coefficient =>
!                rates w. 1 reactant:   s^-1
!                rates w. 2 reactants:  l-h2o mole-1 s^-1 or cm^3 #-1 s^-1 (?)
!                rates w. 3 reactants:  l^2-h2o m-2 s^-1  or cm^6 #-2 s^-1 (?)
!   npderiv  : total # of times Pderiv is called
!   cc2      : array of iarray units holding values of each matrix
!              position actually used;
!              cc2 = P = I - delt * aset(nqq,1) * partial_derivatives
!   urate    : term of Jacobian (J) = partial derivative
!   nfdh1    : nfdh2 + # of rxns with one   active reactant
!
!-----------------------------------------------------------------------------

      subroutine Pderiv  &
     &  (ischan, ktloop, ncsp, nfdh2, nfdh3, nfdl1, nfdl2, irma, irmb,  &
     &   irmc, r1delt, cnew, rrate, npderiv, cc2, urate, nfdh1)

      implicit none

#     include "smv2chem_par.h"
#     include "smv2chem2.h"


!     ----------------------
!     Argument declarations.
!     ----------------------

      integer, intent(in)  :: ischan
      integer, intent(in)  :: ktloop
      integer, intent(in)  :: ncsp
      integer, intent(in)  :: nfdh2, nfdh3
      integer, intent(in)  :: nfdl1, nfdl2
      integer, intent(in)  :: irma (NMTRATE)
      integer, intent(in)  :: irmb (NMTRATE)
      integer, intent(in)  :: irmc (NMTRATE)
      real*8,  intent(in)  :: r1delt
      real*8,  intent(in)  :: cnew (KBLOOP, MXGSAER)
      real*8,  intent(in)  :: rrate(KBLOOP, NMTRATE)

      integer, intent(inout) :: npderiv
      real*8,  intent(inout) :: cc2  (KBLOOP, 0:MXARRAY)
      real*8,  intent(inout) :: urate(KBLOOP, NMTRATE, 3)

      integer, intent(out) :: nfdh1


!     ----------------------
!     Variable declarations.
!     ----------------------

      integer :: ial, iar
      integer :: iarry
      integer :: ja, jb, jc
      integer :: k
      integer :: n, nkn
      integer :: nondiag     ! # of final matrix positions, excluding diagonal
                             ! terms, filled after all matrix processes
      integer :: nondiag1    ! nondiag + 1
      integer :: npdh, npdl

      real*8  :: fracr1


!     ----------------
!     Begin execution.
!     ----------------

!c    Write (6,*) 'Pderiv called.'


!     -----------------------------------------------------------
!     Calculate partial derivatives and sum up partial derivative
!     loss terms.
!     -----------------------------------------------------------

      npderiv  = npderiv + 1
      iarry    = iarray(ncsp)
      nondiag  = iarry - ischan
      nondiag1 = nondiag + 1
      nfdh1    = nfdh2 + ioner(ncsp)
      npdl     = npdlo(ncsp)
      npdh     = npdhi(ncsp)


!     -----------------------------------------------------------
!     Partial derivatives for rates with three active loss terms.
!     -----------------------------------------------------------

      do nkn = 1, nfdh3

        ja = irma(nkn)
        jb = irmb(nkn)
        jc = irmc(nkn)

        do k = 1, ktloop
          urate(k,nkn,1) = rrate(k,nkn) * cnew(k,jb) * cnew(k,jc)
          urate(k,nkn,2) = rrate(k,nkn) * cnew(k,ja) * cnew(k,jc)
          urate(k,nkn,3) = rrate(k,nkn) * cnew(k,ja) * cnew(k,jb)
        end do

      end do


!     ---------------------------------------------------------
!     Partial derivatives for rates with two active loss terms.
!     ---------------------------------------------------------

      do nkn = nfdl2, nfdh2

        ja = irma(nkn)
        jb = irmb(nkn)

        do k = 1, ktloop
          urate(k,nkn,1) = rrate(k,nkn) * cnew(k,jb)
          urate(k,nkn,2) = rrate(k,nkn) * cnew(k,ja)
        end do

      end do


!     --------------------------------------------------------
!     Partial derivatives for rates with one active loss term.
!     --------------------------------------------------------

      do nkn = nfdl1, nfdh1
        do k = 1, ktloop
          urate(k,nkn,1) = rrate(k,nkn)
        end do
      end do


!     ------------------------------------------------------------------
!     Put partial derivatives production and loss terms in matrix array.
!     ------------------------------------------------------------------

      do iar = 1, nondiag
        do k = 1, ktloop
          cc2(k,iar) = 0.0d0
        end do
      end do


      do iar = nondiag1, iarry
        do k = 1, ktloop
          cc2(k,iar) = 1.0d0
        end do
      end do


      do n = npdl, npdh

        nkn    = nkpdterm(n)
        iar    = ipospd  (n)
        ial    = iialpd  (n)
        fracr1 = fracpl  (n) * r1delt

        do k = 1, ktloop
          cc2(k,iar) = cc2(k,iar) + (fracr1 * urate(k,nkn,ial))
        end do

      end do


      return

      end

